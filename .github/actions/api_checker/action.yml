name: "Run ARMOR tool"
description: "Run ARMOR tool"
branding:
  icon: "align-left"
  color: "blue"

inputs:
  event-name:
    description: "github.event_name from the caller"
    required: true
  head-sha:
    description: "Head SHA for the event (PR head or push after)"
    required: true
  base-sha:
    description: "Base SHA for the event (PR base or push before)"
    required: false
    default: ""
  ref:
    description: "Ref associated with the event"
    required: false
    default: ""
  repo:
    description: "owner/repo of the caller"
    required: false
    default: ""
  branch-name:
    description: "Branch name for the event"
    required: true
  armor-repo:
    description: "Repository that contains the ARMOR tool"
    required: false
    default: "qualcomm/armor"
  armor-ref:
    description: "Git ref to checkout for ARMOR tool repo"
    required: false
    default: "main"

runs:
  using: "composite"
  steps:
    - name: Checkout base commit
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.base-sha }}
        path: base
        fetch-depth: 0

    - name: Checkout head commit
      uses: actions/checkout@v4
      with:
        ref: ${{ inputs.head-sha }}
        path: head
        fetch-depth: 0

    - name: Checkout ARMOR tool repository
      uses: actions/checkout@v4
      with:
        repository: qualcomm/armor
        ref: ${{ inputs.armor-ref }}
        path: armor-src
        fetch-depth: 0

    - name: Echo paths and SHAs
      shell: bash
      env:
        EVENT_NAME: ${{ inputs.event-name }}
        BASE_SHA: ${{ inputs.base-sha }}
        HEAD_SHA: ${{ inputs.head-sha }}
      run: |
        echo "Event        : \"$EVENT_NAME\""
        echo "Base SHA     : \"$BASE_SHA\""
        echo "Head SHA     : \"$HEAD_SHA\""
        echo "github-base path  : \"$GITHUB_WORKSPACE/base\""
        echo "github-head path  : \"$GITHUB_WORKSPACE/head\""

    - name: Verify gcc and Docker installation
      shell: bash
      run: |
        set -e
        gcc --version || { echo "gcc missing"; exit 1; }
        docker --version || { echo "docker missing"; exit 1; }

    - name: Install yq
      id: install-yq
      shell: bash
      run: |
        set -e

        # Default output
        echo "yq-installed=false" >> "$GITHUB_OUTPUT"

        # If yq already present, mark installed and exit
        if command -v yq >/dev/null 2>&1; then
          echo "yq already present: $(yq --version || true)"
          echo "yq-installed=true" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        # Install prereqs
        sudo apt-get update -y
        sudo apt-get install -y jq

        # Determine correct yq asset based on architecture
        arch="$(uname -m)"
        case "$arch" in
          x86_64|amd64)   yq_asset="yq_linux_amd64" ;;
          aarch64|arm64)  yq_asset="yq_linux_arm64" ;;
          armv7l|armv7)   yq_asset="yq_linux_arm" ;;
          *)
            echo "::warning::Unsupported architecture for yq: $arch. Skipping yq install."
            exit 0
            ;;
        esac

        # Download and install yq
        sudo wget -qO /usr/local/bin/yq \
          "https://github.com/mikefarah/yq/releases/download/v4.44.3/${yq_asset}"
        sudo chmod +x /usr/local/bin/yq

        echo "Installed yq: $(/usr/local/bin/yq --version 2>&1)"

        if ! /usr/local/bin/yq --version >/dev/null 2>&1; then
          echo "::warning::yq installed but version check failed." >> "$GITHUB_STEP_SUMMARY"
          exit 0
        else
          echo "yq-installed=true" >> "$GITHUB_OUTPUT"
        fi

    - name: Get changed files
      id: changed-files
      shell: bash
      env:
        BASE_SHA: ${{ inputs.base-sha }}
        HEAD_SHA: ${{ inputs.head-sha }}
      run: |
        set -e
        # Diff directly using the two trees
        git --git-dir="$GITHUB_WORKSPACE/head/.git" --work-tree="$GITHUB_WORKSPACE/head" \
          diff --name-only "$BASE_SHA" "$HEAD_SHA" > "$GITHUB_WORKSPACE/changed_files.txt" || true

        echo "Changed files:"
        cat "$GITHUB_WORKSPACE/changed_files.txt" || true

    - name: Check config.yml exists
      if: ${{ steps.install-yq.outputs.yq-installed == 'true' }}
      id: config_exists
      shell: bash
      run: |
        set -euo pipefail
        CONFIG="$GITHUB_WORKSPACE/head/public_headers/config.yml"

        if [[ ! -f "$CONFIG" ]]; then
          echo "configuration file (public_headers/config.yml) not found. Skipping API checks." >> "$GITHUB_STEP_SUMMARY"
          echo "exists=false" >> "$GITHUB_OUTPUT"
          exit 0
        fi

        echo "exists=true" >> "$GITHUB_OUTPUT"

    - name: Parse YAML for headers (dirs/globs allowed) and expand to file list
      if: ${{ steps.install-yq.outputs.yq-installed == 'true' && steps.config_exists.outputs.exists == 'true' }}
      id: parse-yaml
      shell: bash
      env:
        DEBUG: "1"
        TRACE_PATTERNS: "1"
        ACTION_PATH: ${{ github.action_path }}
        BRANCH_NAME: ${{ inputs.branch-name }}
      run: |
        set -euo pipefail
        bash "$ACTION_PATH/scripts/parse_headers.sh" \
          "$GITHUB_WORKSPACE/head/public_headers/config.yml" \
          "$BRANCH_NAME" \
          "$GITHUB_WORKSPACE/head" \
          "$GITHUB_WORKSPACE"

    - name: Find intersection of changed files and headers
      if: ${{ steps.install-yq.outputs.yq-installed == 'true' && steps.config_exists.outputs.exists == 'true' }}
      id: intersection
      shell: bash
      run: |
        set -e
        INTERSECT=$(grep -Fxf "$GITHUB_WORKSPACE/headers.txt" "$GITHUB_WORKSPACE/changed_files.txt" || true)
        echo "$INTERSECT" > "$GITHUB_WORKSPACE/updated_headers_PR.txt"

        if [[ -n "$INTERSECT" ]]; then
          echo "Intersection found:"
          cat "$GITHUB_WORKSPACE/updated_headers_PR.txt"
          echo "has-intersection=true" >> "$GITHUB_OUTPUT"
        else
          echo "No intersection found."
          : > "$GITHUB_WORKSPACE/updated_headers_PR.txt"
          echo "has-intersection=false" >> "$GITHUB_OUTPUT"
          echo "public header changes are not detected. skipping API compatibility checks" >> "$GITHUB_STEP_SUMMARY"
        fi

    - name: Build docker image for armor bins
      if: steps.intersection.outputs.has-intersection == 'true'
      shell: bash
      run: |
        set -euo pipefail
        ARMOR_DIR="$GITHUB_WORKSPACE/armor-src"
        docker build -t armor_tool:latest -f "$ARMOR_DIR/Dockerfile" "$ARMOR_DIR"

    - name: Build ARMOR tool inside container
      if: steps.intersection.outputs.has-intersection == 'true'
      shell: bash
      run: |
        set -euo pipefail
        ARMOR_DIR="$GITHUB_WORKSPACE/armor-src"

        docker run -i --rm \
          --user "$(id -u)":"$(id -g)" \
          -v "$ARMOR_DIR":"$ARMOR_DIR" \
          -e ARMOR_DIR="$ARMOR_DIR" \
          -w "$ARMOR_DIR" \
          armor_tool:latest bash -c '
            set -euo pipefail
            chmod +x ./build_binary.sh
            ./build_binary.sh --build
            echo "$ARMOR_DIR/build/src/armor/armor" > "$ARMOR_DIR/.armor_bins_path"
          '

        # Copy the produced path file into workspace (easier to access outside)
        cp "$ARMOR_DIR/.armor_bins_path" "$GITHUB_WORKSPACE/.armor_bins_path"

    - name: Run header processing inside container
      if: steps.intersection.outputs.has-intersection == 'true'
      id: run-armor
      shell: bash
      env:
        REPORT_FORMAT: "json"
        LOG_LEVEL: "DEBUG"
        DUMP_AST_DIFF: "true"
        ACTION_DIR: ${{ github.action_path }}
        PROJECT_URL: ${{ github.server_url }}/${{ github.repository }}
        BRANCH: ${{ inputs.branch-name }}
        GITHUB_EVENT_NAME: ${{ github.event_name }}
        # Provide PR number only for PR events; empty otherwise
        PR_NUMBER: ${{ github.event_name == 'pull_request' && github.event.pull_request.number || '' }}
        WORKFLOW_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      run: |
        set -euo pipefail
        ARMOR_BINS_PATH="$(cat "$GITHUB_WORKSPACE/.armor_bins_path")"

        docker run -i --rm \
          --user "$(id -u)":"$(id -g)" \
          -e REPORT_FORMAT="$REPORT_FORMAT" \
          -e LOG_LEVEL="$LOG_LEVEL" \
          -e DUMP_AST_DIFF="$DUMP_AST_DIFF" \
          -e PROJECT_URL="$PROJECT_URL" \
          -e BRANCH="$BRANCH" \
          -e GITHUB_EVENT="$GITHUB_EVENT_NAME" \
          -e PR_NUMBER="$PR_NUMBER" \
          -e workflow_url="$WORKFLOW_URL" \
          -e ACTION_DIR="$ACTION_DIR" \
          -e GITHUB_WORKSPACE="$GITHUB_WORKSPACE" \
          -e ARMOR_BINS_PATH="$ARMOR_BINS_PATH" \
          -v "$GITHUB_WORKSPACE":"$GITHUB_WORKSPACE" \
          -v "$ACTION_DIR":"$ACTION_DIR" \
          -w /work \
          armor_tool:latest bash -c '
            set -euo pipefail
            chmod +x "$ACTION_DIR/scripts/run_armor.sh"
            "$ACTION_DIR/scripts/run_armor.sh" \
              "$GITHUB_WORKSPACE/base" \
              "$GITHUB_WORKSPACE/head" \
              "$GITHUB_WORKSPACE/updated_headers_PR.txt" \
              "$ARMOR_BINS_PATH"
          '

        # Expose out-root path
        ls "$GITHUB_WORKSPACE/.armor_out_root"
        OUT_ROOT="$(cat "$GITHUB_WORKSPACE/.armor_out_root")"
        echo "out-root=$OUT_ROOT" >> "$GITHUB_OUTPUT"

    - name: Upload all armor outputs (artifact)
      if: steps.intersection.outputs.has-intersection == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: armor-output-${{ inputs.head-sha }}
        path: ${{ steps.run-armor.outputs.out-root }}
        if-no-files-found: warn

    - name: Compute compatibility status
      id: compatibility_status
      shell: bash
      run: |
        set -e
        STATUS_FILE="$GITHUB_WORKSPACE/.armor_status"
        if [[ -f "$STATUS_FILE" ]]; then
          STATUS="$(cat "$STATUS_FILE")"
        else
          STATUS="success"
        fi
        echo "Overall status: $STATUS"
        echo "res=$STATUS" >> "$GITHUB_OUTPUT"

    - name: Upload folder to S3
      if: steps.intersection.outputs.has-intersection == 'true'
      shell: bash
      env:
        OUT_ROOT: ${{ steps.run-armor.outputs.out-root }}
        SERVER_URL: ${{ github.server_url }}
        REPOSITORY: ${{ github.repository }}
        RUN_ID: ${{ github.run_id }}
      run: |
        set -e
        FOLDER="$OUT_ROOT"
        BUCKET="s3://qli-prd-armor-gh-artifacts"
        YYYY="$(date -u +'%Y')"
        MM="$(date -u +'%m')"
        DD="$(date -u +'%d')"
        HH="$(date -u +'%H')"
        HOST="$(printf '%s' "$SERVER_URL" | sed -E 's#^[a-zA-Z]+://##; s#/.*$##')"
        PREFIX="${YYYY}/${MM}/${DD}/${HH}/${HOST}/${REPOSITORY}/${GITHUB_REF_NAME}/${RUN_ID}/files"
        echo "Uploading artifacts to Destination: ${BUCKET}/${PREFIX}"
        set +e
        ERR_FILE="$(mktemp)"
        aws s3 cp "$FOLDER" "${BUCKET}/${PREFIX}" \
          --recursive \
          --content-type "application/octet-stream" \
          --only-show-errors \
          2> "$ERR_FILE"
        rc=$?
        set -e
        if [[ ${rc} -eq 0 ]]; then
          echo "S3 upload succeeded."
        else
          reason="$(cat "$ERR_FILE")"
          echo "::error :: S3 upload FAILED (rc=${rc})."
          echo "::error :: Reason: ${reason:-No error output captured}"
        fi
        rm -f "$ERR_FILE"

    - name: Prepare ARMOR summary
      if: steps.intersection.outputs.has-intersection == 'true'
      id: prepare-comment
      shell: bash
      env:
        WORKFLOW_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
        OUT_ROOT: ${{ steps.run-armor.outputs.out-root }}
        STATUS: ${{ steps.compatibility_status.outputs.res }}
      run: |
        set -euo pipefail
        artifacts="${WORKFLOW_URL}#artifacts"
        out_root="$OUT_ROOT"
        blk="${out_root}/incompatible_blocking.txt"
        nbk="${out_root}/incompatible_nonblocking.txt"
        status="$STATUS"

        body="$(cat <<'EOF'
        ### ARMOR Check Result
        **Status:** __STATUS__
        Please check __ARTIFACTS__ for details.
        EOF
        )"
        body="${body/__STATUS__/${status}}"
        body="${body/__ARTIFACTS__/${artifacts}}"

        # Segregated incompatible lists
        body+=$'\n\n**Backward Incompatible Headers (segregated):**\n'
        if [[ -s "$blk" ]]; then
          body+=$'\n**Blocking:**\n'
          while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            body+=$'- '"$line"$'\n'
          done < "$blk"
        fi

        if [[ -s "$nbk" ]]; then
          body+=$'\n**Non-blocking:**\n'
          while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            body+=$'- '"$line"$'\n'
          done < "$nbk"
        fi

        delimiter="EOF_SUMMARY_$(date +%s)"
        {
          echo "body<<$delimiter"
          printf '%s\n' "$body"
          echo "$delimiter"
        } >> "$GITHUB_OUTPUT"

    - name: Fail if incompatible changes detected
      if: steps.intersection.outputs.has-intersection == 'true'
      shell: bash
      run: |
        set -euo pipefail
        status="${{ steps.compatibility_status.outputs.res }}"
        printf '%s\n' "${{ steps.prepare-comment.outputs.body }}" >> "$GITHUB_STEP_SUMMARY"
        if [[ "$status" == "failure" ]]; then
          echo "::error ::ARMOR detected backward incompatible changes in blocking headers. Failing the check."
          exit 1
        else
          echo "ARMOR check passed (status: $status)."
        fi
